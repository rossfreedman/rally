{% extends "mobile/layout.html" %}
{% set show_back_arrow = True %}

{% block content %}
<div class="min-h-screen bg-gray-50">
    
    <!-- Header -->
    <div class="bg-white border-b border-gray-100">
        <div class="flex items-center px-4 py-6">
            <div class="w-12 h-12 rounded-full flex items-center justify-center shadow-sm" style="background-color: #10645c !important;">
                <i class="fas fa-save text-white text-lg"></i>
            </div>
            <div class="ml-4">
                <h1 class="text-xl font-bold text-gray-900">Saved Lineups</h1>
                <p class="text-sm text-gray-500">Manage your saved team lineups</p>
            </div>
        </div>
    </div>

    <!-- Content -->
    <div class="px-4 space-y-6" style="padding-top: calc(1.5rem - 5px); padding-bottom: 1.5rem;">
        
        <!-- Loading State -->
        <div id="loading-state" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div class="p-6 text-center">
                <i class="fas fa-spinner fa-spin text-gray-400 text-2xl mb-3"></i>
                <p class="text-gray-500">Loading saved lineups...</p>
            </div>
        </div>

        <!-- Empty State -->
        <div id="empty-state" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden hidden">
            <div class="p-6 text-center">
                <i class="fas fa-clipboard-list text-gray-400 text-4xl mb-4"></i>
                <h3 class="text-lg font-semibold text-gray-900 mb-2">No Saved Lineups</h3>
                <p class="text-gray-500 mb-4">You haven't saved any lineups yet. Create a lineup to get started!</p>
                <a href="/mobile/lineup" class="inline-flex items-center px-4 py-2 text-white rounded-lg transition-colors" style="background-color: #10645c !important;" onmouseover="this.style.backgroundColor='#0d5249'" onmouseout="this.style.backgroundColor='#10645c'">
                    <i class="fas fa-plus mr-2"></i>
                    Create New Lineup
                </a>
            </div>
        </div>

        <!-- Saved Lineups List -->
        <div id="lineups-container" class="space-y-4 hidden">
            <!-- Lineups will be dynamically loaded here -->
        </div>

        <!-- Action Buttons -->
        <div id="action-buttons" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden hidden">
            <div class="p-4">
                <a href="/mobile/lineup" class="w-full text-purple-600 bg-purple-50 hover:bg-purple-100 rounded-lg p-3 font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-plus mr-2"></i>
                    Create New Lineup
                </a>
            </div>
        </div>
    </div>
</div>



<script>
// Initialize session data
window.sessionData = {{ session_data | tojson | safe }};
const user = window.sessionData?.user || {};
const teamId = user.team_id || '';

// Load saved lineups when page loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('üîç Session data:', window.sessionData);
    console.log('üîç User data:', user);
    console.log('üîç Team ID:', teamId);
    loadSavedLineups();
    
    // Set up event delegation for lineup buttons
    setupEventDelegation();
});

async function loadSavedLineups() {
    try {
        showLoadingState();
        
        console.log('üîç Loading saved lineups for team:', teamId);
        const response = await fetch(`/api/saved-lineups?team_id=${encodeURIComponent(teamId)}`);
        console.log('üì° API response status:', response.status);
        const data = await response.json();
        console.log('üìä API response data:', data);
        
        if (!data.success) {
            throw new Error(data.error || 'Failed to load lineups');
        }
        
        if (data.lineups.length === 0) {
            showEmptyState();
        } else {
            displayLineups(data.lineups);
        }
        
    } catch (error) {
        console.error('Error loading saved lineups:', error);
        showErrorState(error.message);
    }
}

function showLoadingState() {
    document.getElementById('loading-state').classList.remove('hidden');
    document.getElementById('empty-state').classList.add('hidden');
    document.getElementById('lineups-container').classList.add('hidden');
    document.getElementById('action-buttons').classList.add('hidden');
}

function showEmptyState() {
    document.getElementById('loading-state').classList.add('hidden');
    document.getElementById('empty-state').classList.remove('hidden');
    document.getElementById('lineups-container').classList.add('hidden');
    document.getElementById('action-buttons').classList.add('hidden');
}

function showErrorState(message) {
    document.getElementById('loading-state').classList.add('hidden');
    document.getElementById('empty-state').classList.add('hidden');
    document.getElementById('lineups-container').classList.add('hidden');
    document.getElementById('action-buttons').classList.add('hidden');
    
    // Show error in a simple alert for now
    alert(`Error loading lineups: ${message}`);
}

function displayLineups(lineups) {
    document.getElementById('loading-state').classList.add('hidden');
    document.getElementById('empty-state').classList.add('hidden');
    document.getElementById('lineups-container').classList.remove('hidden');
    document.getElementById('action-buttons').classList.remove('hidden');
    
    const container = document.getElementById('lineups-container');
    container.innerHTML = '';
    
    lineups.forEach(lineup => {
        const lineupCard = createLineupCard(lineup);
        container.appendChild(lineupCard);
    });
}

function createLineupCard(lineup) {
    const card = document.createElement('div');
    card.className = 'bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden';
    
    const formattedDate = new Date(lineup.updated_at).toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
    
    // Parse lineup data to extract players and courts
    const courts = parseLineupData(lineup.data);
    
    card.innerHTML = `
        <div class="px-6 py-4 border-b border-gray-50">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold text-gray-900">${escapeHtml(lineup.name)}</h3>
                <span class="text-sm text-gray-500">${formattedDate}</span>
            </div>
        </div>
        <div class="p-6">
            <div class="bg-gray-50 rounded-lg p-4 mb-4">
                <div id="lineup-display-${lineup.id}" class="text-sm text-gray-800 whitespace-pre-wrap font-mono">
                    <div class="flex items-center justify-center py-4">
                        <i class="fas fa-spinner fa-spin text-gray-400 mr-2"></i>
                        <span class="text-gray-500">Loading PTI data...</span>
                    </div>
                </div>
            </div>
            <div class="flex gap-3">
                <button data-lineup-id="${lineup.id}" class="edit-lineup-btn flex-1 px-4 py-2 text-purple-600 bg-purple-50 hover:bg-purple-100 rounded-lg font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-edit mr-2"></i>
                    Edit
                </button>
                <button data-lineup-id="${lineup.id}" class="delete-lineup-btn flex-1 px-4 py-2 text-red-600 bg-red-50 hover:bg-red-100 rounded-lg font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-trash mr-2"></i>
                    Delete
                </button>
                <button data-lineup-data="${encodeURIComponent(lineup.data)}" class="use-lineup-btn flex-1 px-4 py-2 text-green-600 bg-green-50 hover:bg-green-100 rounded-lg font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-play mr-2"></i>
                    Use
                </button>
            </div>
        </div>
    `;
    
    // Load PTI data asynchronously after DOM is ready
    setTimeout(() => {
        loadPTIDataForLineup(lineup.id, courts);
    }, 100);
    
    return card;
}

function parseLineupData(lineupData) {
    const courts = [];
    
    // Check if this is the new enhanced format (JSON with player IDs)
    let enhancedData = null;
    let displayText = lineupData;
    
    // Debug logging to see what format we're dealing with
    console.log('üîß Parsing lineup data:', lineupData.substring(0, 100) + '...');
    
    try {
        enhancedData = JSON.parse(lineupData);
        console.log('üîß Parsed JSON successfully:', enhancedData);
        if (enhancedData.version === '2.0' && enhancedData.display_text) {
            displayText = enhancedData.display_text;
            console.log('üîß Using enhanced lineup format with player IDs');
            console.log('üîß Player data available:', enhancedData.player_data);
        } else {
            // Not the enhanced format, use as plain text
            console.log('üîß Not enhanced format, using as plain text');
            enhancedData = null;
        }
    } catch (e) {
        // Not JSON, use as plain text (old format)
        console.log('üîß Not JSON format, using as plain text (old format)');
        enhancedData = null;
    }
    
    // Normalize the text by converting <br> tags to newlines and decoding HTML entities
    let normalizedText = displayText.replace(/<br\s*\/?>/gi, '\n');
    normalizedText = normalizedText.replace(/&amp;/g, '&');
    normalizedText = normalizedText.replace(/&lt;/g, '<');
    normalizedText = normalizedText.replace(/&gt;/g, '>');
    normalizedText = normalizedText.replace(/&quot;/g, '"');
    normalizedText = normalizedText.replace(/&nbsp;/g, ' '); // Handle non-breaking spaces
    
    const lines = normalizedText.split('\n');
    
    let currentCourt = null;
    let currentPlayers = [];
    
    lines.forEach(line => {
        const trimmedLine = line.trim();
        
        // Match pattern: "Court X:" or "Court X: (Avg PTI: XX.X)" to start a new court
        const courtMatch = trimmedLine.match(/^Court (\d+):/);
        if (courtMatch) {
            // Save previous court if it exists
            if (currentCourt && currentPlayers.length > 0) {
                courts.push({
                    court: currentCourt,
                    players: currentPlayers
                });
            }
            
            // Start new court
            currentCourt = parseInt(courtMatch[1], 10);
            currentPlayers = [];
        } else if (trimmedLine && currentCourt) {
            // This is a player line under the current court
            const playerLine = trimmedLine.replace(/^\s+/, ''); // Remove leading spaces
            
            // Skip PTI summary lines like "(Avg PTI: 53.6, Total PTI: 107.2)"
            if (playerLine.match(/^\(Avg PTI:/) || playerLine.match(/^\(Total PTI:/)) {
                console.log(`üîß Skipping PTI summary line: ${playerLine}`);
                return; // Skip this line
            }
            
            if (playerLine && !playerLine.includes('[Need Partner]')) {
                // Extract just the player name (PTI values are in parentheses)
                const cleanPlayerName = playerLine.replace(/\s*\(\d+\.?\d*\)\s*$/, '').trim();
                if (cleanPlayerName) {
                    // Try to find player ID from enhanced data
                    let playerId = null;
                    if (enhancedData && enhancedData.player_data && enhancedData.player_data[currentCourt]) {
                        const courtData = enhancedData.player_data[currentCourt];
                        console.log(`üîß Looking for player ID for ${cleanPlayerName} in court ${currentCourt}:`, courtData);
                        if (courtData['1'] && courtData['1'].name === cleanPlayerName) {
                            playerId = courtData['1'].player_id;
                            console.log(`üîß Found player ID for ${cleanPlayerName}: ${playerId}`);
                        } else if (courtData['2'] && courtData['2'].name === cleanPlayerName) {
                            playerId = courtData['2'].player_id;
                            console.log(`üîß Found player ID for ${cleanPlayerName}: ${playerId}`);
                        } else {
                            console.log(`üîß No player ID found for ${cleanPlayerName} in court ${currentCourt}`);
                        }
                    } else {
                        console.log(`üîß No enhanced data or court data for ${cleanPlayerName} in court ${currentCourt}`);
                    }
                    
                    currentPlayers.push({
                        name: cleanPlayerName,
                        player_id: playerId
                    });
                }
            }
        }
    });
    
    // Don't forget the last court
    if (currentCourt && currentPlayers.length > 0) {
        courts.push({
            court: currentCourt,
            players: currentPlayers
        });
    }
    
    return courts;
}

async function loadPTIDataForLineup(lineupId, courts) {
    try {
        // Check if the DOM element exists
        const displayElement = document.getElementById(`lineup-display-${lineupId}`);
        if (!displayElement) {
            console.error(`Display element not found for lineup ${lineupId}`);
            return;
        }
        
        // Get all unique players from all courts
        const allPlayers = [];
        courts.forEach(court => {
            court.players.forEach(player => {
                // Check if we already have this player (by name or ID)
                const existingPlayer = allPlayers.find(p => 
                    p.name === player.name || 
                    (player.player_id && p.player_id === player.player_id)
                );
                if (!existingPlayer) {
                    allPlayers.push(player);
                }
            });
        });
        
        if (allPlayers.length === 0) {
            displayElement.innerHTML = '<div class="text-gray-500 text-center py-4">No players found in lineup</div>';
            return;
        }
        
        // Fetch PTI data for all players
        const ptiData = await fetchPTIDataForPlayers(allPlayers);
        
        // Display the lineup with PTI information
        displayLineupWithPTI(lineupId, courts, ptiData);
        
    } catch (error) {
        console.error('Error loading PTI data:', error);
        const displayElement = document.getElementById(`lineup-display-${lineupId}`);
        if (displayElement) {
            displayElement.innerHTML = '<div class="text-red-500 text-center py-4">Error loading PTI data</div>';
        }
    }
}

async function fetchPTIDataForPlayers(players) {
    const ptiData = {};
    
    // Fetch PTI data for each player
    for (const player of players) {
        try {
            let response;
            let playerKey;
            
            if (player.player_id) {
                // Use player ID-based lookup for accurate PTI data
                console.log(`üîß Fetching PTI for ${player.name} using player ID: ${player.player_id}`);
                response = await fetch(`/api/player-history-by-id/${encodeURIComponent(player.player_id)}`);
                playerKey = player.player_id;
            } else {
                // Fallback to name-based lookup for old lineups
                console.log(`üîß Fetching PTI for ${player.name} using name-based lookup (no player ID)`);
                response = await fetch(`/api/player-history/${encodeURIComponent(player.name)}`);
                playerKey = player.name;
            }
            
            const data = await response.json();
            console.log(`üîß PTI response for ${player.name}:`, data);
            
            if (data && data.current_pti !== undefined) {
                ptiData[playerKey] = data.current_pti;
                console.log(`üîß Set PTI for ${player.name}: ${data.current_pti}`);
            } else {
                ptiData[playerKey] = null; // No PTI data available
                console.log(`üîß No PTI data for ${player.name}`);
            }
        } catch (error) {
            console.error(`Error fetching PTI for ${player.name || player.player_id}:`, error);
            ptiData[player.player_id || player.name] = null;
        }
    }
    
    return ptiData;
}

function displayLineupWithPTI(lineupId, courts, ptiData) {
    const displayElement = document.getElementById(`lineup-display-${lineupId}`);
    
    if (!displayElement) {
        console.error(`Display element not found for lineup ${lineupId}`);
        return;
    }
    
    let html = '';
    
    courts.forEach(court => {
        const courtNum = court.court;
        const players = court.players;
        
        // Calculate combined PTI for this court
        let combinedPTI = 0;
        let ptiCount = 0;
        let playerPTIs = [];
        
        players.forEach(player => {
            const playerKey = player.player_id || player.name;
            const pti = ptiData[playerKey];
            if (pti !== null && pti !== undefined) {
                combinedPTI += pti;
                ptiCount++;
                playerPTIs.push(`${player.name} (${pti})`);
            } else {
                playerPTIs.push(`${player.name}`);
            }
        });
        
        const avgPTI = ptiCount > 0 ? (combinedPTI / ptiCount).toFixed(1) : 'N/A';
        
        html += `Court ${courtNum}: (Average PTI: ${avgPTI})\n`;
        playerPTIs.forEach(playerPTI => {
            html += `  ${playerPTI}\n`;
        });
        html += '\n';
    });
    
    displayElement.innerHTML = `<pre class="text-sm text-gray-800 whitespace-pre-wrap font-mono">${html}</pre>`;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function editLineup(lineupId) {
    try {
        // Find the lineup data
        const response = await fetch(`/api/saved-lineups?team_id=${encodeURIComponent(teamId)}`);
        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || 'Failed to load lineup');
        }
        
        const lineup = data.lineups.find(l => l.id === lineupId);
        if (!lineup) {
            throw new Error('Lineup not found');
        }
        
        // Store the lineup data for the lineup builder to load and pre-populate
        console.log('üîß Storing lineup data for editing:');
        console.log('  - lineup.data:', lineup.data);
        console.log('  - lineup.name:', lineup.name);
        console.log('  - lineupId:', lineupId);
        
        sessionStorage.setItem('loadLineupData', lineup.data);
        sessionStorage.setItem('editLineupId', lineupId.toString());
        sessionStorage.setItem('editLineupName', lineup.name);
        sessionStorage.setItem('isEditMode', 'true');
        
        // Verify storage
        console.log('üîß Verification - stored in sessionStorage:');
        console.log('  - loadLineupData:', sessionStorage.getItem('loadLineupData'));
        console.log('  - editLineupId:', sessionStorage.getItem('editLineupId'));
        console.log('  - editLineupName:', sessionStorage.getItem('editLineupName'));
        console.log('  - isEditMode:', sessionStorage.getItem('isEditMode'));
        
        // Redirect to the manual lineup builder page (where drag-and-drop happens)
        window.location.href = '/mobile/lineup';
        
    } catch (error) {
        console.error('Error loading lineup for edit:', error);
        alert(`Error: ${error.message}`);
    }
}



async function deleteLineup(lineupId) {
    if (!confirm('Are you sure you want to delete this lineup? This action cannot be undone.')) {
        return;
    }
    
    try {
        const response = await fetch('/api/saved-lineups', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                lineup_id: lineupId,
                team_id: teamId
            })
        });
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.error || 'Failed to delete lineup');
        }
        
        alert('Lineup deleted successfully!');
        loadSavedLineups(); // Refresh the list
        
    } catch (error) {
        console.error('Error deleting lineup:', error);
        alert(`Error deleting lineup: ${error.message}`);
    }
}

function setupEventDelegation() {
    // Handle lineup button clicks using event delegation
    document.addEventListener('click', (e) => {
        if (e.target.closest('.use-lineup-btn')) {
            console.log('üîß Use lineup button clicked');
            const button = e.target.closest('.use-lineup-btn');
            const encodedLineupData = button.getAttribute('data-lineup-data');
            console.log('üîß encodedLineupData from button:', encodedLineupData);
            
            if (encodedLineupData) {
                // Decode the URI-encoded lineup data
                const lineupData = decodeURIComponent(encodedLineupData);
                console.log('üîß decoded lineupData:', lineupData);
                useLineup(lineupData);
            } else {
                console.error('‚ùå No lineup data found on button');
            }
        } else if (e.target.closest('.edit-lineup-btn')) {
            const button = e.target.closest('.edit-lineup-btn');
            const lineupId = button.getAttribute('data-lineup-id');
            if (lineupId) {
                editLineup(parseInt(lineupId));
            }
        } else if (e.target.closest('.delete-lineup-btn')) {
            const button = e.target.closest('.delete-lineup-btn');
            const lineupId = button.getAttribute('data-lineup-id');
            if (lineupId) {
                deleteLineup(parseInt(lineupId));
            }
        }
    });
}

function useLineup(lineupData) {
    console.log('üîß useLineup called with:', lineupData);
    
    try {
        // Try to parse the lineup data as JSON first
        let parsedData = null;
        try {
            parsedData = JSON.parse(lineupData);
            console.log('üîß Parsed lineup data:', parsedData);
        } catch (e) {
            console.log('üîß Lineup data is not JSON, using as-is');
        }
        
        let formattedLineupData;
        
        if (parsedData && parsedData.display_text) {
            // Use the display_text from the JSON data
            formattedLineupData = parsedData.display_text;
            console.log('üîß Using display_text from JSON:', formattedLineupData);
        } else {
            // Use the raw data as-is (for older lineups)
            formattedLineupData = lineupData;
            console.log('üîß Using raw lineup data:', formattedLineupData);
        }
        
        // Store the formatted lineup data for the confirmation page
        sessionStorage.setItem('createdLineup', formattedLineupData);
        console.log('üîß Stored createdLineup in sessionStorage:', formattedLineupData);
        
        window.location.href = '/mobile/lineup-confirmation';
    } catch (error) {
        console.error('‚ùå Error in useLineup:', error);
        // Fallback: store the raw data
        sessionStorage.setItem('createdLineup', lineupData);
        window.location.href = '/mobile/lineup-confirmation';
    }
}
</script>

<style>
/* Custom styles matching the mobile design system */
.min-h-screen {
    min-height: 100vh;
}

/* Background utilities */
.bg-gray-50 { background-color: #f9fafb; }
.bg-gray-100 { background-color: #f3f4f6; }
.bg-gray-200 { background-color: #e5e7eb; }
.bg-white { background-color: #ffffff; }
.bg-purple-50 { background-color: #faf5ff; }
.bg-purple-100 { background-color: #f3e8ff; }
.bg-purple-600 { background-color: #9333ea; }
.bg-red-50 { background-color: #fef2f2; }
.bg-red-100 { background-color: #fee2e2; }
.bg-green-50 { background-color: #f0fdf4; }
.bg-green-100 { background-color: #dcfce7; }

/* Text utilities */
.text-gray-900 { color: #111827; }
.text-gray-800 { color: #1f2937; }
.text-gray-700 { color: #374151; }
.text-gray-600 { color: #4b5563; }
.text-gray-500 { color: #6b7280; }
.text-gray-400 { color: #9ca3af; }
.text-white { color: #ffffff; }
.text-purple-600 { color: #9333ea; }
.text-red-600 { color: #dc2626; }
.text-green-600 { color: #16a34a; }

/* Border utilities */
.border-gray-100 { border-color: #f3f4f6; }
.border-gray-50 { border-color: #f9fafb; }
.border-gray-300 { border-color: #d1d5db; }

/* Spacing utilities */
.space-y-6 > * + * { margin-top: 1.5rem; }
.space-y-4 > * + * { margin-top: 1rem; }

/* Flexbox utilities */
.flex { display: flex; }
.items-center { align-items: center; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }

/* Width utilities */
.w-full { width: 100%; }
.w-12 { width: 3rem; }
.h-12 { height: 3rem; }
.max-w-md { max-width: 28rem; }

/* Margin utilities */
.ml-4 { margin-left: 1rem; }
.mr-2 { margin-right: 0.5rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-3 { margin-bottom: 0.75rem; }
.mb-4 { margin-bottom: 1rem; }
.mb-6 { margin-bottom: 1.5rem; }

/* Padding utilities */
.px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
.px-4 { padding-left: 1rem; padding-right: 1rem; }
.px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
.py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
.py-4 { padding-top: 1rem; padding-bottom: 1rem; }
.py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
.p-3 { padding: 0.75rem; }
.p-4 { padding: 1rem; }
.p-6 { padding: 1.5rem; }

/* Border radius utilities */
.rounded-xl { border-radius: 0.75rem; }
.rounded-lg { border-radius: 0.5rem; }
.rounded-full { border-radius: 9999px; }

/* Shadow utilities */
.shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
.shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }

/* Font utilities */
.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }
.font-mono { font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace; }

/* Text size utilities */
.text-xl { font-size: 1.25rem; line-height: 1.75rem; }
.text-lg { font-size: 1.125rem; line-height: 1.75rem; }
.text-sm { font-size: 0.875rem; line-height: 1.25rem; }
.text-2xl { font-size: 1.5rem; line-height: 2rem; }
.text-4xl { font-size: 2.25rem; line-height: 2.5rem; }

/* Layout utilities */
.block { display: block; }
.inline-flex { display: inline-flex; }
.overflow-hidden { overflow: hidden; }
.whitespace-pre-wrap { white-space: pre-wrap; }
.hidden { display: none; }
.fixed { position: fixed; }
.inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
.z-50 { z-index: 50; }
.min-h-screen { min-height: 100vh; }

/* Hover utilities */
.hover\:bg-gray-200:hover { background-color: #e5e7eb; }
.hover\:bg-purple-100:hover { background-color: #f3e8ff; }
.hover\:bg-purple-700:hover { background-color: #7c3aed; }
.hover\:bg-red-100:hover { background-color: #fee2e2; }
.hover\:bg-green-100:hover { background-color: #dcfce7; }

/* Transition utilities */
.transition-colors {
    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 150ms;
}

/* Focus utilities */
.focus\:ring-2:focus { box-shadow: 0 0 0 2px rgba(147, 51, 234, 0.5); }
.focus\:ring-purple-500:focus { box-shadow: 0 0 0 2px rgba(147, 51, 234, 0.5); }
.focus\:border-purple-500:focus { border-color: #9333ea; }

/* Form utilities */
input, textarea {
    border: 1px solid #d1d5db;
}

/* Background opacity */
.bg-opacity-50 { background-color: rgba(0, 0, 0, 0.5); }

/* Gap utilities */
.gap-3 { gap: 0.75rem; }

/* Flex utilities */
.flex-1 { flex: 1 1 0%; }

/* Text alignment */
.text-center { text-align: center; }

/* Animation utilities */
.fa-spin {
    animation: fa-spin 2s infinite linear;
}

@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Responsive design */
@media (max-width: 640px) {
    .px-6 { padding-left: 1rem; padding-right: 1rem; }
    .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
}
</style>
{% endblock %}
