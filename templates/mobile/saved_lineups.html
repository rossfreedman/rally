{% extends "mobile/layout.html" %}
{% set show_back_arrow = True %}

{% block content %}
<div class="min-h-screen bg-gray-50">
    
    <!-- Header -->
    <div class="bg-white border-b border-gray-100">
        <div class="flex items-center px-4 py-6">
            <div class="w-12 h-12 rounded-full flex items-center justify-center shadow-sm" style="background-color: #10645c !important;">
                <i class="fas fa-save text-white text-lg"></i>
            </div>
            <div class="ml-4">
                <h1 class="text-xl font-bold text-gray-900">Saved Lineups</h1>
                <p class="text-sm text-gray-500">Manage your saved team lineups</p>
            </div>
        </div>
    </div>

    <!-- Content -->
    <div class="px-4 space-y-6" style="padding-top: calc(1.5rem - 5px); padding-bottom: 1.5rem;">
        
        <!-- Loading State -->
        <div id="loading-state" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div class="p-6 text-center">
                <i class="fas fa-spinner fa-spin text-gray-400 text-2xl mb-3"></i>
                <p class="text-gray-500">Loading saved lineups...</p>
            </div>
        </div>

        <!-- Empty State -->
        <div id="empty-state" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden hidden">
            <div class="p-6 text-center">
                <i class="fas fa-clipboard-list text-gray-400 text-4xl mb-4"></i>
                <h3 class="text-lg font-semibold text-gray-900 mb-2">No Saved Lineups</h3>
                <p class="text-gray-500 mb-4">You haven't saved any lineups yet. Create a lineup to get started!</p>
                <a href="/mobile/lineup" class="inline-flex items-center px-4 py-2 text-white rounded-lg transition-colors" style="background-color: #10645c !important;" onmouseover="this.style.backgroundColor='#0d5249'" onmouseout="this.style.backgroundColor='#10645c'">
                    <i class="fas fa-plus mr-2"></i>
                    Create New Lineup
                </a>
            </div>
        </div>

        <!-- Saved Lineups List -->
        <div id="lineups-container" class="space-y-4 hidden">
            <!-- Lineups will be dynamically loaded here -->
        </div>

        <!-- Action Buttons -->
        <div id="action-buttons" class="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden hidden">
            <div class="p-4">
                <a href="/mobile/lineup" class="w-full text-purple-600 bg-purple-50 hover:bg-purple-100 rounded-lg p-3 font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-plus mr-2"></i>
                    Create New Lineup
                </a>
            </div>
        </div>
    </div>
</div>



<script>
// Initialize session data
window.sessionData = {{ session_data | tojson | safe }};
const user = window.sessionData?.user || {};
const teamId = user.team_id || '';

// Load saved lineups when page loads
document.addEventListener('DOMContentLoaded', () => {
    console.log('🔍 Session data:', window.sessionData);
    console.log('🔍 User data:', user);
    console.log('🔍 Team ID:', teamId);
    loadSavedLineups();
    
    // Set up event delegation for lineup buttons
    setupEventDelegation();
});

async function loadSavedLineups() {
    try {
        showLoadingState();
        
        console.log('🔍 Loading saved lineups for team:', teamId);
        const response = await fetch(`/api/saved-lineups?team_id=${encodeURIComponent(teamId)}`);
        console.log('📡 API response status:', response.status);
        const data = await response.json();
        console.log('📊 API response data:', data);
        
        if (!data.success) {
            throw new Error(data.error || 'Failed to load lineups');
        }
        
        if (data.lineups.length === 0) {
            showEmptyState();
        } else {
            displayLineups(data.lineups);
        }
        
    } catch (error) {
        console.error('Error loading saved lineups:', error);
        showErrorState(error.message);
    }
}

function showLoadingState() {
    document.getElementById('loading-state').classList.remove('hidden');
    document.getElementById('empty-state').classList.add('hidden');
    document.getElementById('lineups-container').classList.add('hidden');
    document.getElementById('action-buttons').classList.add('hidden');
}

function showEmptyState() {
    document.getElementById('loading-state').classList.add('hidden');
    document.getElementById('empty-state').classList.remove('hidden');
    document.getElementById('lineups-container').classList.add('hidden');
    document.getElementById('action-buttons').classList.add('hidden');
}

function showErrorState(message) {
    document.getElementById('loading-state').classList.add('hidden');
    document.getElementById('empty-state').classList.add('hidden');
    document.getElementById('lineups-container').classList.add('hidden');
    document.getElementById('action-buttons').classList.add('hidden');
    
    // Show error in a simple alert for now
    alert(`Error loading lineups: ${message}`);
}

function displayLineups(lineups) {
    document.getElementById('loading-state').classList.add('hidden');
    document.getElementById('empty-state').classList.add('hidden');
    document.getElementById('lineups-container').classList.remove('hidden');
    document.getElementById('action-buttons').classList.remove('hidden');
    
    const container = document.getElementById('lineups-container');
    container.innerHTML = '';
    
    lineups.forEach(lineup => {
        const lineupCard = createLineupCard(lineup);
        container.appendChild(lineupCard);
    });
}

function createLineupCard(lineup) {
    const card = document.createElement('div');
    card.className = 'bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden';
    
    const formattedDate = new Date(lineup.updated_at).toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
    
    // Parse lineup data to extract players and courts
    const courts = parseLineupData(lineup.data);
    
    card.innerHTML = `
        <div class="px-6 py-4 border-b border-gray-50">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold text-gray-900">${escapeHtml(lineup.name)}</h3>
                <span class="text-sm text-gray-500">${formattedDate}</span>
            </div>
        </div>
        <div class="p-6">
            <div class="bg-gray-50 rounded-lg p-4 mb-4">
                <div id="lineup-display-${lineup.id}" class="text-sm text-gray-800 whitespace-pre-wrap font-mono">
                    <div class="flex items-center justify-center py-4">
                        <i class="fas fa-spinner fa-spin text-gray-400 mr-2"></i>
                        <span class="text-gray-500">Loading PTI data...</span>
                    </div>
                </div>
            </div>
            <div class="flex gap-3">
                <button data-lineup-id="${lineup.id}" class="edit-lineup-btn flex-1 px-4 py-2 text-purple-600 bg-purple-50 hover:bg-purple-100 rounded-lg font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-edit mr-2"></i>
                    Edit
                </button>
                <button data-lineup-id="${lineup.id}" class="delete-lineup-btn flex-1 px-4 py-2 text-red-600 bg-red-50 hover:bg-red-100 rounded-lg font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-trash mr-2"></i>
                    Delete
                </button>
                <button data-lineup-data="${escapeHtml(lineup.data)}" class="use-lineup-btn flex-1 px-4 py-2 text-green-600 bg-green-50 hover:bg-green-100 rounded-lg font-semibold transition-colors flex items-center justify-center">
                    <i class="fas fa-play mr-2"></i>
                    Use
                </button>
            </div>
        </div>
    `;
    
    // Load PTI data asynchronously after DOM is ready
    setTimeout(() => {
        loadPTIDataForLineup(lineup.id, courts);
    }, 100);
    
    return card;
}

function parseLineupData(lineupData) {
    const courts = [];
    
    // Normalize the text by converting <br> tags to newlines and decoding HTML entities
    let normalizedText = lineupData.replace(/<br\s*\/?>/gi, '\n');
    normalizedText = normalizedText.replace(/&amp;/g, '&');
    normalizedText = normalizedText.replace(/&lt;/g, '<');
    normalizedText = normalizedText.replace(/&gt;/g, '>');
    normalizedText = normalizedText.replace(/&quot;/g, '"');
    normalizedText = normalizedText.replace(/&nbsp;/g, ' '); // Handle non-breaking spaces
    
    const lines = normalizedText.split('\n');
    
    let currentCourt = null;
    let currentPlayers = [];
    
    lines.forEach(line => {
        const trimmedLine = line.trim();
        
        // Match pattern: "Court X:" or "Court X: (Avg PTI: XX.X)" to start a new court
        const courtMatch = trimmedLine.match(/^Court (\d+):/);
        if (courtMatch) {
            // Save previous court if it exists
            if (currentCourt && currentPlayers.length > 0) {
                courts.push({
                    court: currentCourt,
                    players: currentPlayers
                });
            }
            
            // Start new court
            currentCourt = parseInt(courtMatch[1], 10);
            currentPlayers = [];
        } else if (trimmedLine && currentCourt) {
            // This is a player name under the current court
            const playerName = trimmedLine.replace(/^\s+/, ''); // Remove leading spaces
            if (playerName && !playerName.includes('[Need Partner]')) {
                // Extract just the player name, removing PTI values in parentheses
                const cleanPlayerName = playerName.replace(/\s*\(\d+\.?\d*\)\s*$/, '').trim();
                if (cleanPlayerName) {
                    currentPlayers.push(cleanPlayerName);
                }
            }
        }
    });
    
    // Don't forget the last court
    if (currentCourt && currentPlayers.length > 0) {
        courts.push({
            court: currentCourt,
            players: currentPlayers
        });
    }
    
    return courts;
}

async function loadPTIDataForLineup(lineupId, courts) {
    try {
        // Check if the DOM element exists
        const displayElement = document.getElementById(`lineup-display-${lineupId}`);
        if (!displayElement) {
            console.error(`Display element not found for lineup ${lineupId}`);
            return;
        }
        
        // Get all unique player names from all courts
        const allPlayers = [];
        courts.forEach(court => {
            court.players.forEach(player => {
                if (!allPlayers.includes(player)) {
                    allPlayers.push(player);
                }
            });
        });
        
        if (allPlayers.length === 0) {
            displayElement.innerHTML = '<div class="text-gray-500 text-center py-4">No players found in lineup</div>';
            return;
        }
        
        // Fetch PTI data for all players
        const ptiData = await fetchPTIDataForPlayers(allPlayers);
        
        // Display the lineup with PTI information
        displayLineupWithPTI(lineupId, courts, ptiData);
        
    } catch (error) {
        console.error('Error loading PTI data:', error);
        const displayElement = document.getElementById(`lineup-display-${lineupId}`);
        if (displayElement) {
            displayElement.innerHTML = '<div class="text-red-500 text-center py-4">Error loading PTI data</div>';
        }
    }
}

async function fetchPTIDataForPlayers(playerNames) {
    const ptiData = {};
    
    // Fetch PTI data for each player
    for (const playerName of playerNames) {
        try {
            const response = await fetch(`/api/player-history/${encodeURIComponent(playerName)}`);
            const data = await response.json();
            
            if (data && data.current_pti !== undefined) {
                ptiData[playerName] = data.current_pti;
            } else {
                ptiData[playerName] = null; // No PTI data available
            }
        } catch (error) {
            console.error(`Error fetching PTI for ${playerName}:`, error);
            ptiData[playerName] = null;
        }
    }
    
    return ptiData;
}

function displayLineupWithPTI(lineupId, courts, ptiData) {
    const displayElement = document.getElementById(`lineup-display-${lineupId}`);
    
    if (!displayElement) {
        console.error(`Display element not found for lineup ${lineupId}`);
        return;
    }
    
    let html = '';
    
    courts.forEach(court => {
        const courtNum = court.court;
        const players = court.players;
        
        // Calculate combined PTI for this court
        let combinedPTI = 0;
        let ptiCount = 0;
        let playerPTIs = [];
        
        players.forEach(player => {
            const pti = ptiData[player];
            if (pti !== null && pti !== undefined) {
                combinedPTI += pti;
                ptiCount++;
                playerPTIs.push(`${player} (${pti})`);
            } else {
                playerPTIs.push(`${player}`);
            }
        });
        
        const avgPTI = ptiCount > 0 ? (combinedPTI / ptiCount).toFixed(1) : 'N/A';
        
        html += `Court ${courtNum}: (Average PTI: ${avgPTI})\n`;
        playerPTIs.forEach(playerPTI => {
            html += `  ${playerPTI}\n`;
        });
        html += '\n';
    });
    
    displayElement.innerHTML = `<pre class="text-sm text-gray-800 whitespace-pre-wrap font-mono">${html}</pre>`;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function editLineup(lineupId) {
    try {
        // Find the lineup data
        const response = await fetch(`/api/saved-lineups?team_id=${encodeURIComponent(teamId)}`);
        const data = await response.json();
        
        if (!data.success) {
            throw new Error(data.error || 'Failed to load lineup');
        }
        
        const lineup = data.lineups.find(l => l.id === lineupId);
        if (!lineup) {
            throw new Error('Lineup not found');
        }
        
        // Store the lineup data for the lineup builder to load and pre-populate
        console.log('🔧 Storing lineup data for editing:');
        console.log('  - lineup.data:', lineup.data);
        console.log('  - lineup.name:', lineup.name);
        console.log('  - lineupId:', lineupId);
        
        sessionStorage.setItem('loadLineupData', lineup.data);
        sessionStorage.setItem('editLineupId', lineupId.toString());
        sessionStorage.setItem('editLineupName', lineup.name);
        sessionStorage.setItem('isEditMode', 'true');
        
        // Verify storage
        console.log('🔧 Verification - stored in sessionStorage:');
        console.log('  - loadLineupData:', sessionStorage.getItem('loadLineupData'));
        console.log('  - editLineupId:', sessionStorage.getItem('editLineupId'));
        console.log('  - editLineupName:', sessionStorage.getItem('editLineupName'));
        console.log('  - isEditMode:', sessionStorage.getItem('isEditMode'));
        
        // Redirect to the manual lineup builder page (where drag-and-drop happens)
        window.location.href = '/mobile/lineup';
        
    } catch (error) {
        console.error('Error loading lineup for edit:', error);
        alert(`Error: ${error.message}`);
    }
}



async function deleteLineup(lineupId) {
    if (!confirm('Are you sure you want to delete this lineup? This action cannot be undone.')) {
        return;
    }
    
    try {
        const response = await fetch('/api/saved-lineups', {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                lineup_id: lineupId,
                team_id: teamId
            })
        });
        
        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.error || 'Failed to delete lineup');
        }
        
        alert('Lineup deleted successfully!');
        loadSavedLineups(); // Refresh the list
        
    } catch (error) {
        console.error('Error deleting lineup:', error);
        alert(`Error deleting lineup: ${error.message}`);
    }
}

function setupEventDelegation() {
    // Handle lineup button clicks using event delegation
    document.addEventListener('click', (e) => {
        if (e.target.closest('.use-lineup-btn')) {
            const button = e.target.closest('.use-lineup-btn');
            const lineupData = button.getAttribute('data-lineup-data');
            if (lineupData) {
                useLineup(lineupData);
            }
        } else if (e.target.closest('.edit-lineup-btn')) {
            const button = e.target.closest('.edit-lineup-btn');
            const lineupId = button.getAttribute('data-lineup-id');
            if (lineupId) {
                editLineup(parseInt(lineupId));
            }
        } else if (e.target.closest('.delete-lineup-btn')) {
            const button = e.target.closest('.delete-lineup-btn');
            const lineupId = button.getAttribute('data-lineup-id');
            if (lineupId) {
                deleteLineup(parseInt(lineupId));
            }
        }
    });
}

function useLineup(lineupData) {
    // Store the lineup data for the confirmation page
    sessionStorage.setItem('createdLineup', lineupData);
    window.location.href = '/mobile/lineup-confirmation';
}
</script>

<style>
/* Custom styles matching the mobile design system */
.min-h-screen {
    min-height: 100vh;
}

/* Background utilities */
.bg-gray-50 { background-color: #f9fafb; }
.bg-gray-100 { background-color: #f3f4f6; }
.bg-gray-200 { background-color: #e5e7eb; }
.bg-white { background-color: #ffffff; }
.bg-purple-50 { background-color: #faf5ff; }
.bg-purple-100 { background-color: #f3e8ff; }
.bg-purple-600 { background-color: #9333ea; }
.bg-red-50 { background-color: #fef2f2; }
.bg-red-100 { background-color: #fee2e2; }
.bg-green-50 { background-color: #f0fdf4; }
.bg-green-100 { background-color: #dcfce7; }

/* Text utilities */
.text-gray-900 { color: #111827; }
.text-gray-800 { color: #1f2937; }
.text-gray-700 { color: #374151; }
.text-gray-600 { color: #4b5563; }
.text-gray-500 { color: #6b7280; }
.text-gray-400 { color: #9ca3af; }
.text-white { color: #ffffff; }
.text-purple-600 { color: #9333ea; }
.text-red-600 { color: #dc2626; }
.text-green-600 { color: #16a34a; }

/* Border utilities */
.border-gray-100 { border-color: #f3f4f6; }
.border-gray-50 { border-color: #f9fafb; }
.border-gray-300 { border-color: #d1d5db; }

/* Spacing utilities */
.space-y-6 > * + * { margin-top: 1.5rem; }
.space-y-4 > * + * { margin-top: 1rem; }

/* Flexbox utilities */
.flex { display: flex; }
.items-center { align-items: center; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }

/* Width utilities */
.w-full { width: 100%; }
.w-12 { width: 3rem; }
.h-12 { height: 3rem; }
.max-w-md { max-width: 28rem; }

/* Margin utilities */
.ml-4 { margin-left: 1rem; }
.mr-2 { margin-right: 0.5rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-3 { margin-bottom: 0.75rem; }
.mb-4 { margin-bottom: 1rem; }
.mb-6 { margin-bottom: 1.5rem; }

/* Padding utilities */
.px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
.px-4 { padding-left: 1rem; padding-right: 1rem; }
.px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
.py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
.py-4 { padding-top: 1rem; padding-bottom: 1rem; }
.py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
.p-3 { padding: 0.75rem; }
.p-4 { padding: 1rem; }
.p-6 { padding: 1.5rem; }

/* Border radius utilities */
.rounded-xl { border-radius: 0.75rem; }
.rounded-lg { border-radius: 0.5rem; }
.rounded-full { border-radius: 9999px; }

/* Shadow utilities */
.shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
.shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }

/* Font utilities */
.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }
.font-mono { font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace; }

/* Text size utilities */
.text-xl { font-size: 1.25rem; line-height: 1.75rem; }
.text-lg { font-size: 1.125rem; line-height: 1.75rem; }
.text-sm { font-size: 0.875rem; line-height: 1.25rem; }
.text-2xl { font-size: 1.5rem; line-height: 2rem; }
.text-4xl { font-size: 2.25rem; line-height: 2.5rem; }

/* Layout utilities */
.block { display: block; }
.inline-flex { display: inline-flex; }
.overflow-hidden { overflow: hidden; }
.whitespace-pre-wrap { white-space: pre-wrap; }
.hidden { display: none; }
.fixed { position: fixed; }
.inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
.z-50 { z-index: 50; }
.min-h-screen { min-height: 100vh; }

/* Hover utilities */
.hover\:bg-gray-200:hover { background-color: #e5e7eb; }
.hover\:bg-purple-100:hover { background-color: #f3e8ff; }
.hover\:bg-purple-700:hover { background-color: #7c3aed; }
.hover\:bg-red-100:hover { background-color: #fee2e2; }
.hover\:bg-green-100:hover { background-color: #dcfce7; }

/* Transition utilities */
.transition-colors {
    transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 150ms;
}

/* Focus utilities */
.focus\:ring-2:focus { box-shadow: 0 0 0 2px rgba(147, 51, 234, 0.5); }
.focus\:ring-purple-500:focus { box-shadow: 0 0 0 2px rgba(147, 51, 234, 0.5); }
.focus\:border-purple-500:focus { border-color: #9333ea; }

/* Form utilities */
input, textarea {
    border: 1px solid #d1d5db;
}

/* Background opacity */
.bg-opacity-50 { background-color: rgba(0, 0, 0, 0.5); }

/* Gap utilities */
.gap-3 { gap: 0.75rem; }

/* Flex utilities */
.flex-1 { flex: 1 1 0%; }

/* Text alignment */
.text-center { text-align: center; }

/* Animation utilities */
.fa-spin {
    animation: fa-spin 2s infinite linear;
}

@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Responsive design */
@media (max-width: 640px) {
    .px-6 { padding-left: 1rem; padding-right: 1rem; }
    .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
}
</style>
{% endblock %}
