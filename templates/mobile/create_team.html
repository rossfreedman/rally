{% extends "mobile/layout.html" %}
{% set show_back_arrow = True %}

{% block title %}Rally - Create Team{% endblock %}

{% block content %}
<div class="min-h-screen bg-gray-50">
    <!-- Desktop Only Alert -->
    <div class="bg-amber-50 border border-amber-200 rounded-xl mb-4 p-4 shadow-sm">
        <div class="flex items-center gap-3">
            <div class="flex-shrink-0">
                <i class="fas fa-desktop text-amber-600 text-lg"></i>
            </div>
            <div class="flex-1">
                <p class="text-sm font-medium text-amber-800">
                    <span class="font-semibold">Desktop Optimized:</span> This page works on mobile but is optimized for desktop viewing. For the best experience with all three columns visible side-by-side, please use a computer or tablet in landscape mode.
                </p>
            </div>
            <div class="flex-shrink-0">
                <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" class="text-amber-600 hover:text-amber-800 transition-colors">
                    <i class="fas fa-times text-sm"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Page Header -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-100 mb-4">
        <div class="flex items-center gap-4 p-4">
            <div class="w-12 h-12 bg-blue-600 rounded-full flex items-center justify-center shadow-sm">
                <i class="fas fa-users-cog text-white text-xl"></i>
            </div>
            <div>
                <h1 class="text-xl font-bold text-gray-900">Create Team</h1>
                <p class="text-sm text-gray-600">PTI-based team assignment with expert guidance</p>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div id="loading-state" class="py-12 text-center">
        <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
        <p class="mt-4 text-lg text-gray-600">Loading player data...</p>
        <button onclick="forceShowContent()" class="mt-4 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
            Force Show Content (Debug)
        </button>
    </div>

    <!-- Mobile Detection Message -->
    <div id="mobile-only-message" class="hidden p-8 text-center">
        <div class="bg-yellow-50 border border-yellow-200 rounded-xl p-6 max-w-md mx-auto">
            <div class="flex items-center justify-center mb-4">
                <i class="fas fa-desktop text-yellow-600 text-3xl"></i>
            </div>
            <h2 class="text-xl font-bold text-gray-900 mb-2">Desktop Required</h2>
            <p class="text-gray-700 mb-4">This page is only viewable on a desktop computer.</p>
            <p class="text-sm text-gray-600">Please access this page from a computer or tablet in landscape mode for the full team creation experience.</p>
        </div>
    </div>

    <!-- Main Content Container - Desktop Only -->
    <div id="create-team-content" class="hidden" style="display: none !important;">
        <!-- Force 3-Column Layout Always -->
        <div class="grid grid-cols-3 gap-6 min-h-screen">
            
            <!-- Column 1: Interactive PTI Range Control -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-100 h-fit">
                <div class="px-4 py-3 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-indigo-50">
                    <div class="flex items-center justify-between">
                        <div>
                            <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                                <i class="fas fa-sliders-h text-blue-600 mr-2"></i>
                                Series PTI Ranges
                            </h2>
                            <p class="text-sm text-gray-600 mt-1">Click <strong>Balance</strong> to create contiguous PTI ranges (no gaps) with equal range spans per series. Adjust ranges manually - all series automatically maintain sequential order with no overlaps.</p>
                        </div>
                        <button id="calculate-balanced-ranges" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-green-600 bg-white border border-green-200 rounded-lg hover:bg-green-50 hover:text-green-700 transition-colors mr-2">
                            <i class="fas fa-calculator text-xs"></i>
                            Balance
                        </button>
                        <button id="reset-ranges" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-blue-600 bg-white border border-blue-200 rounded-lg hover:bg-blue-50 hover:text-blue-700 transition-colors">
                            <i class="fas fa-undo text-xs"></i>
                            Reset
                        </button>
                    </div>
                </div>
                <div class="p-4 max-h-96 overflow-y-auto">
                    <!-- Individual Series PTI Controls -->
                    <div id="series-recommendations" class="space-y-4">
                        <!-- Series with individual PTI sliders will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Column 2: Available Players -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-100 h-fit">
                <div class="px-4 py-3 border-b border-gray-100 bg-gradient-to-r from-green-50 to-emerald-50">
                    <div class="flex items-center justify-between">
                        <div>
                            <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                                <i class="fas fa-users text-green-600 mr-2"></i>
                                Available Players
                                <span id="player-count" class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-1 rounded-full"></span>
                            </h2>
                            <p class="text-sm text-gray-600 mt-1">Drag players to assign to series or tap to select. Tennaqua players only.</p>
                            <div class="mt-2 p-2 bg-gray-50 rounded-lg">
                                <p class="text-xs font-medium text-gray-700 mb-1">PTI Color Guide:</p>
                                <div class="flex flex-wrap gap-1 text-xs">
                                    <span class="bg-emerald-200 border border-emerald-400 text-emerald-900 px-1 py-0.5 rounded font-medium">0-9</span>
                                    <span class="bg-green-200 border border-green-400 text-green-900 px-1 py-0.5 rounded font-medium">10-19</span>
                                    <span class="bg-lime-200 border border-lime-400 text-lime-900 px-1 py-0.5 rounded font-medium">20-29</span>
                                    <span class="bg-yellow-200 border border-yellow-400 text-yellow-900 px-1 py-0.5 rounded font-medium">30-39</span>
                                    <span class="bg-amber-200 border border-amber-400 text-amber-900 px-1 py-0.5 rounded font-medium">40-49</span>
                                    <span class="bg-orange-200 border border-orange-400 text-orange-900 px-1 py-0.5 rounded font-medium">50-59</span>
                                    <span class="bg-red-200 border border-red-400 text-red-900 px-1 py-0.5 rounded font-medium">60-69</span>
                                    <span class="bg-rose-200 border border-rose-400 text-rose-900 px-1 py-0.5 rounded font-medium">70-79</span>
                                    <span class="bg-purple-200 border border-purple-400 text-purple-900 px-1 py-0.5 rounded font-medium">80+</span>
                                </div>
                            </div>
                        </div>
                        <button id="reset-players" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-green-600 bg-white border border-green-200 rounded-lg hover:bg-green-50 hover:text-green-700 transition-colors">
                            <i class="fas fa-undo text-xs"></i>
                            Reset
                        </button>
                    </div>
                </div>
                <div class="p-4 max-h-96 overflow-y-auto">
                    <div id="available-players-pool" class="min-h-24 bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-4 drop-zone"
                         ondragover="handleDragOver(event)"
                         ondragenter="handleDragEnter(event)"
                         ondragleave="handleDragLeave(event)"
                         ondrop="handleDropToPool(event)">
                        <div class="text-gray-400 text-center text-sm" id="loading-players">Loading players...</div>
                    </div>
                </div>
            </div>

            <!-- Column 3: Series Teams Display -->
            <div class="bg-white rounded-xl shadow-sm border border-gray-100 h-fit">
                <div class="px-4 py-3 border-b border-gray-100 bg-gradient-to-r from-purple-50 to-pink-50">
                    <div class="flex items-center justify-between">
                        <div>
                            <h2 class="text-lg font-semibold text-gray-900 flex items-center">
                                <i class="fas fa-users-cog text-purple-600 mr-2"></i>
                                Team Assignments
                            </h2>
                            <p class="text-sm text-gray-600 mt-1">Drop players here to assign. Double-click assigned players to remove.</p>
                            <p class="text-xs text-blue-600 mt-1">
                                <i class="fas fa-info-circle mr-1"></i>
                                <strong>Target Team PTI</strong> shows total team PTI range (individual PTI × team size).
                            </p>
                        </div>
                        <button id="reset-assignments" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-purple-600 bg-white border border-purple-200 rounded-lg hover:bg-purple-50 hover:text-purple-700 transition-colors">
                            <i class="fas fa-undo text-xs"></i>
                            Reset
                        </button>
                    </div>
                </div>
                <div class="p-4 max-h-96 overflow-y-auto">
                    <div id="series-teams" class="space-y-4">
                        <!-- Series containers will be dynamically created here -->
                    </div>
                </div>
            </div>

        </div>

        <!-- Selected Player Indicator (for tap mode) -->
        <div id="selected-player-indicator" class="bg-yellow-100 border border-yellow-300 rounded-lg p-4 mt-4 hidden">
            <div class="flex items-center justify-between">
                <div>
                    <span class="text-sm font-medium text-yellow-800">Selected: </span>
                    <span id="selected-player-name" class="text-sm text-yellow-900 font-semibold"></span>
                    <span id="selected-player-pti" class="text-xs text-yellow-700 ml-2"></span>
                </div>
                <button id="clear-selection" class="text-yellow-600 hover:text-yellow-800 text-sm px-3 py-1 rounded">
                    Clear Selection
                </button>
            </div>
            <p class="text-xs text-yellow-700 mt-2">Tap a series range to assign this player</p>
        </div>

        <!-- Action Buttons -->
        <div class="flex gap-3 pt-6 justify-center">
            <button id="save-teams" class="bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-all font-semibold disabled:bg-gray-400 disabled:cursor-not-allowed">
                <i class="fas fa-save mr-2"></i>
                Save Teams
            </button>
            <button id="reset-teams" class="bg-gray-600 text-white px-6 py-3 rounded-lg shadow-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all font-semibold">
                <i class="fas fa-undo mr-2"></i>
                Reset
            </button>
        </div>
    </div>
</div>

<style>
/* Mobile-specific styles for create team */
.player-card {
    transition: all 0.2s ease;
    cursor: pointer;
    user-select: none;
    min-height: 44px;
    padding: 0.75rem !important;
    margin: 0.5rem !important;
    width: 140px !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    justify-content: center !important;
    text-align: center !important;
    border-radius: 8px !important;
}

.player-card:hover, .player-card:active {
    transform: scale(0.98);
    background-color: rgba(59, 130, 246, 0.1);
}

.player-card.selected {
    background-color: rgba(59, 130, 246, 0.2) !important;
    border: 2px solid #3b82f6 !important;
}

/* Player pool container styling */
#available-players-pool {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: flex-start;
    gap: 0.5rem;
}

/* Drop zones styling */
.drop-zone {
    transition: all 0.3s ease;
    min-height: 60px;
    border: 2px dashed #d1d5db;
    border-radius: 8px;
    padding: 1rem;
    margin: 0.5rem 0;
    cursor: pointer;
    position: relative;
    height: auto !important;
    max-height: none !important;
    overflow: visible !important;
}

.drop-zone.drop-zone-active {
    border-color: #3b82f6 !important;
    background-color: #eff6ff !important;
    border-style: solid !important;
    transform: scale(1.02);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
}

/* Team assignment container styling */
.drop-zone > div {
    min-height: inherit;
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    align-content: flex-start;
    justify-content: flex-start;
}

/* Compact player cards for team assignments */
.drop-zone .player-card {
    width: calc(50% - 0.25rem) !important; /* Two columns with gap */
    max-width: calc(50% - 0.25rem) !important;
    min-width: 0;
    flex: 0 0 calc(50% - 0.25rem);
    text-align: center;
    padding: 0.375rem 0.25rem !important; /* Smaller padding */
    font-size: 0.7rem !important; /* Smaller text */
    line-height: 1.2;
    box-sizing: border-box;
}

/* Make player card content more compact */
.drop-zone .player-card > div {
    margin: 0.125rem 0;
    font-size: 0.65rem;
}

/* Smaller text for remove instruction */
.drop-zone .player-card .text-xs {
    font-size: 0.6rem !important;
    margin-top: 0.125rem !important;
    opacity: 0.6;
}

/* Drag and drop styling */
.player-card[draggable="true"] {
    cursor: grab;
    user-select: none;
    flex-shrink: 0; /* Prevent cards from shrinking */
}

.player-card[draggable="true"]:active {
    cursor: grabbing;
}

.player-card.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
    z-index: 1000;
}

/* Drop zone highlight animation */
.drop-zone.drop-zone-active::before {
    content: "Drop player here";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(59, 130, 246, 0.9);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 500;
    pointer-events: none;
    opacity: 0;
    animation: fadeIn 0.2s ease-in-out forwards;
}

@keyframes fadeIn {
    to { opacity: 1; }
}

/* PTI Color Coding */
.pti-0 { background-color: #dcfce7; border-color: #16a34a; color: #15803d; }
.pti-10 { background-color: #dcfce7; border-color: #16a34a; color: #15803d; }
.pti-20 { background-color: #ecfdf5; border-color: #10b981; color: #047857; }
.pti-30 { background-color: #fef3c7; border-color: #f59e0b; color: #92400e; }
.pti-40 { background-color: #fde68a; border-color: #f59e0b; color: #92400e; }
.pti-50 { background-color: #fed7aa; border-color: #ea580c; color: #9a3412; }
.pti-60 { background-color: #fecaca; border-color: #ef4444; color: #b91c1c; }
.pti-70 { background-color: #fce7f3; border-color: #ec4899; color: #be185d; }
.pti-80 { background-color: #e9d5ff; border-color: #a855f7; color: #7c2d12; }

/* Force 3-column desktop layout */
.grid-cols-3 {
    grid-template-columns: repeat(3, 1fr);
}

/* Ensure columns have equal width and proper spacing */
#create-team-content .grid {
    width: 100%;
    max-width: none;
}

/* Column specific styling */
#create-team-content .grid > div {
    min-width: 0; /* Allow content to shrink */
    max-width: 100%; /* Prevent overflow */
}

/* PTI Slider Styling */
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    border-radius: 3px;
    background: #e5e7eb;
    outline: none;
    transition: background 0.3s;
}

input[type="range"]:hover {
    background: #d1d5db;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

input[type="range"]::-webkit-slider-thumb:hover {
    background: #2563eb;
    transform: scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
    border: none;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

input[type="range"]::-moz-range-thumb:hover {
    background: #2563eb;
    transform: scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

/* Series Slider Specific Styling */
.series-slider {
    background: linear-gradient(to right, #e5e7eb 0%, #3b82f6 50%, #e5e7eb 100%);
    transition: all 0.3s ease;
}

.series-slider:hover {
    background: linear-gradient(to right, #d1d5db 0%, #2563eb 50%, #d1d5db 100%);
}

.series-slider::-webkit-slider-thumb {
    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
}

.series-slider::-webkit-slider-thumb:hover {
    background: linear-gradient(135deg, #2563eb, #1e40af);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.6);
}

.series-slider::-moz-range-thumb {
    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
}

.series-slider::-moz-range-thumb:hover {
    background: linear-gradient(135deg, #2563eb, #1e40af);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.6);
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize session data
    window.sessionData = {{ session_data | tojson | safe }};

    // Mobile Detection - Show message if on mobile
    function isMobileDevice() {
        return window.innerWidth < 1024 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    if (isMobileDevice()) {
        console.log('Mobile device detected - showing mobile message');
        document.getElementById('loading-state').style.display = 'none';
        document.getElementById('mobile-only-message').classList.remove('hidden');
        document.getElementById('mobile-only-message').style.display = 'block';
        return; // Don't initialize the rest of the page
    }

    // Desktop detected - proceed with normal initialization
    console.log('Desktop device detected - initializing team creation page');

    // Immediate element check
    console.log('DOM loaded, checking elements...');
    const loadingState = document.getElementById('loading-state');
    const mainContent = document.getElementById('create-team-content');
    console.log('Loading state found:', !!loadingState);
    console.log('Create team content found:', !!mainContent);
    if (loadingState) console.log('Loading state classes:', loadingState.className);
    if (mainContent) console.log('Create team content classes:', mainContent.className);

    // Global variables
    let allPlayers = [];
    let originalPlayers = []; // Store original unfiltered players
    let seriesRanges = [];
    let teamAssignments = {};
    let selectedPlayerForTap = null;
    let playersPerSeries = {}; // Store target players per series (default: 10)

    // PTI Color Coding Function
    function getPTIColorClass(pti) {
        const segment = Math.floor(pti / 10);
        const colorClasses = [
            'bg-emerald-200 border-emerald-400 text-emerald-900',
            'bg-green-200 border-green-400 text-green-900',
            'bg-lime-200 border-lime-400 text-lime-900',
            'bg-yellow-200 border-yellow-400 text-yellow-900',
            'bg-amber-200 border-amber-400 text-amber-900',
            'bg-orange-200 border-orange-400 text-orange-900',
            'bg-red-200 border-red-400 text-red-900',
            'bg-rose-200 border-rose-400 text-rose-900',
            'bg-purple-200 border-purple-400 text-purple-900'
        ];
        return colorClasses[segment] || colorClasses[colorClasses.length - 1];
    }

    // Reset individual series ranges to original values
    function resetSeriesRanges() {
        console.log('Resetting all series ranges to original values');
        
        // Reset each series to its original range
        seriesRanges.forEach(series => {
            // For now, we'll reload the page to get original data
            // In a full implementation, you'd store original ranges
            console.log(`Resetting ${series.series_name} to original range`);
        });
        
        // Simple reset - reload the series data
        location.reload();
    }

    // Calculate balanced PTI ranges using stratification
    async function calculateBalancedRanges() {
        console.log('Calculating balanced PTI ranges...');
        
        try {
            // Show loading state
            const balanceButton = document.getElementById('calculate-balanced-ranges');
            const originalText = balanceButton.innerHTML;
            balanceButton.innerHTML = '<i class="fas fa-spinner fa-spin text-xs"></i> Calculating...';
            balanceButton.disabled = true;
            
            const response = await fetch('/api/create-team/calculate-balanced-ranges', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            const data = await response.json();
            
            console.log('🔍 Full API Response:', data);
            console.log('🔍 Response Status:', response.status);
            console.log('🔍 Response OK:', response.ok);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${data.error || 'Unknown error'}`);
            }
            
            if (data.success && data.series_ranges) {
                console.log('Balanced ranges calculated successfully:', data);
                
                // Update seriesRanges with balanced data
                seriesRanges = data.series_ranges;
                
                // Refresh the UI with new balanced ranges
                displaySeriesControls();
                displaySeriesTeams();
                
                // Show success message with summary
                const summary = data.stratification_summary;
                const message = `✅ Contiguous ranges calculated!\n\n` +
                    `${data.total_players} players across ${data.total_series} series\n` +
                    `${summary.pti_range_per_series} PTI points per series\n` +
                    `Total PTI range: ${summary.lowest_pti} - ${summary.highest_pti}\n\n` +
                    `Method: ${summary.description}`;
                
                alert(message);
                
            } else {
                console.error('❌ API returned unsuccessful response:', data);
                throw new Error(data.error || 'Failed to calculate balanced ranges');
            }
            
        } catch (error) {
            console.error('❌ Error calculating balanced ranges:', error);
            
            // Show more detailed error message
            let errorMessage = error.message;
            if (errorMessage.includes('No players with PTI data found')) {
                errorMessage = 'No players with PTI data found. Make sure players have valid PTI values assigned.';
            } else if (errorMessage.includes('No series found')) {
                errorMessage = 'No series found. Make sure your league has series configured.';
            }
            
            alert(`Failed to calculate balanced ranges:\n\n${errorMessage}`);
        } finally {
            // Restore button state
            const balanceButton = document.getElementById('calculate-balanced-ranges');
            balanceButton.innerHTML = '<i class="fas fa-calculator text-xs"></i> Balance';
            balanceButton.disabled = false;
        }
    }

    // Series PTI Range Management Functions - REFACTORED
    let updateTimeout = null; // Debouncing
    let pendingUpdates = new Set(); // Track pending updates
    let isUpdating = false; // Prevent concurrent updates

    window.updateSeriesPTIRange = async function(seriesName, type, value) {
        console.log(`🎯 Updating ${seriesName} ${type} PTI to ${value}`);
        
        const numValue = parseFloat(value);
        const seriesIndex = seriesRanges.findIndex(s => s.series_name === seriesName);
        
        if (seriesIndex === -1) {
            console.error('❌ Series not found:', seriesName);
            return;
        }
        
        const series = seriesRanges[seriesIndex];
        const seriesId = series.series_name.replace(/\s+/g, '-');
        
        // Update the local range with validation
        if (type === 'min') {
            // Ensure min doesn't exceed max
            if (numValue >= series.current_range.max) {
                series.current_range.max = parseFloat((numValue + 0.01).toFixed(2));
                updateSliderValue(seriesId, 'max', series.current_range.max);
            }
            series.current_range.min = parseFloat(numValue.toFixed(2));
        } else {
            // Ensure max doesn't go below min
            if (numValue <= series.current_range.min) {
                series.current_range.min = parseFloat((numValue - 0.01).toFixed(2));
                updateSliderValue(seriesId, 'min', series.current_range.min);
            }
            series.current_range.max = parseFloat(numValue.toFixed(2));
        }
        
        // Update UI immediately for responsiveness
        updateSeriesDisplay(seriesId, series);
        
        // Debounce the API call to prevent spam
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(async () => {
            await debouncedRangeUpdate(seriesName, series);
        }, 500); // Wait 500ms after user stops changing values
    };

    async function debouncedRangeUpdate(seriesName, series) {
        if (isUpdating || pendingUpdates.has(seriesName)) {
            console.log(`⏳ Skipping update for ${seriesName} - already in progress`);
            return;
        }

        try {
            isUpdating = true;
            pendingUpdates.add(seriesName);
            
            console.log(`🚀 Processing update for ${seriesName}`);
            
            // Fix sequential order first
            await fixSequentialOrder();
            
            // Then send the update to backend
            await updateSeriesRangeBackend(seriesName, series.current_range);
            
            console.log(`✅ Successfully updated ${seriesName}`);
            
        } catch (error) {
            console.error(`❌ Failed to update ${seriesName}:`, error);
            showUpdateError(seriesName, error.message);
        } finally {
            pendingUpdates.delete(seriesName);
            isUpdating = false;
        }
    }

    async function fixSequentialOrder() {
        console.log('🔧 Ensuring sequential order...');
        
        // Sort series by numeric order (Series 1, Series 2, etc.)
        function getSeriesNumber(seriesName) {
            const match = seriesName.match(/(\d+)/);
            return match ? parseInt(match[1]) : 999;
        }
        
        const sortedSeries = [...seriesRanges].sort((a, b) => {
            return getSeriesNumber(a.series_name) - getSeriesNumber(b.series_name);
        });
        
        let adjustmentsMade = false;
        
        // Ensure each series starts where the previous one ends
        for (let i = 1; i < sortedSeries.length; i++) {
            const prevSeries = sortedSeries[i - 1];
            const currentSeries = sortedSeries[i];
            const expectedMin = prevSeries.current_range.max + 0.01;
            
            // Only adjust if there's actually a gap or overlap
            if (Math.abs(currentSeries.current_range.min - expectedMin) > 0.01) {
                currentSeries.current_range.min = parseFloat(expectedMin.toFixed(2));
                adjustmentsMade = true;
                
                // Update in main array
                const mainIndex = seriesRanges.findIndex(s => s.series_name === currentSeries.series_name);
                if (mainIndex !== -1) {
                    seriesRanges[mainIndex].current_range.min = currentSeries.current_range.min;
                }
                
                console.log(`📐 Adjusted ${currentSeries.series_name}: min set to ${currentSeries.current_range.min}`);
            }
        }
        
        if (adjustmentsMade) {
            // Refresh UI to show adjustments
            displaySeriesControls();
            console.log('✅ Sequential order maintained');
        } else {
            console.log('✅ Sequential order was already correct');
        }
    }

    function updateSliderValue(seriesId, type, value) {
        const slider = document.getElementById(`${type}-pti-slider-${seriesId}`);
        const valueSpan = document.getElementById(`${type}-pti-value-${seriesId}`);
        
        if (slider) slider.value = value;
        if (valueSpan) valueSpan.textContent = value.toFixed(2);
    }

    function updateSeriesDisplay(seriesId, series) {
        const rangeSpan = document.getElementById(`current-range-${seriesId}`);
        const minValueSpan = document.getElementById(`min-pti-value-${seriesId}`);
        const maxValueSpan = document.getElementById(`max-pti-value-${seriesId}`);
        
        if (rangeSpan) {
            rangeSpan.textContent = `${series.current_range.min.toFixed(2)} - ${series.current_range.max.toFixed(2)}`;
        }
        if (minValueSpan) {
            minValueSpan.textContent = series.current_range.min.toFixed(2);
        }
        if (maxValueSpan) {
            maxValueSpan.textContent = series.current_range.max.toFixed(2);
        }
    }

    function showUpdateError(seriesName, errorMessage) {
        const seriesId = seriesName.replace(/\s+/g, '-');
        const seriesContainer = document.getElementById(`series-${seriesId}`);
        
        if (seriesContainer) {
            // Create or update error message
            let errorDiv = document.getElementById(`error-${seriesId}`);
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.id = `error-${seriesId}`;
                errorDiv.className = 'bg-red-50 border border-red-200 rounded-lg p-2 mt-2';
                seriesContainer.appendChild(errorDiv);
            }
            
            errorDiv.innerHTML = `
                <div class="flex items-center text-red-800">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    <span class="text-xs">Update failed: ${errorMessage}</span>
                </div>
            `;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }
    }

    async function updateSeriesRangeBackend(seriesName, newRange) {
        try {
            console.log(`📡 Sending ${seriesName} range to backend:`, newRange);
            
            const response = await fetch('/api/create-team/update-series-range', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    series_name: seriesName,
                    min_pti: newRange.min,
                    max_pti: newRange.max
                })
            });

            const data = await response.json();
            
            if (!response.ok || !data.success) {
                throw new Error(data.error || `HTTP ${response.status}`);
            }
            
            console.log(`✅ Backend confirmed update for ${seriesName}`);
            return data;
            
        } catch (error) {
            console.error(`❌ Backend update failed for ${seriesName}:`, error);
            throw error;
        }
    }

    // Remove the old problematic functions
    async function resolveRangeConflicts(changedSeriesName, changedSeries) {
        // This function is now handled automatically
        console.log('📝 Note: Range conflicts are now handled automatically');
    }

    function showConflictWarning(seriesId) {
        // Not needed with new system
    }

    function hideConflictWarning(seriesId) {
        // Not needed with new system  
    }

    // Initialize page with mobile-optimized functionality
    async function initializePage() {
        try {
            console.log('Starting page initialization...');
            await loadPlayers();
            await loadSeriesRanges();
            setupEventListeners();
            showContent();
            console.log('Page initialization complete');
        } catch (error) {
            console.error('Error initializing page:', error);
            showError('Failed to load data. Please refresh the page.');
        }
    }

    // Load players from API
    async function loadPlayers() {
        try {
            const response = await fetch('/api/create-team/players');
            if (!response.ok) throw new Error('Failed to fetch players');
            
            const data = await response.json();
            if (!data.success) {
                throw new Error(data.error || 'Failed to load players');
            }
            
            // Filter to only Tennaqua players
            const tennaquaPlayers = data.players.filter(player => 
                player.club && player.club.toLowerCase().includes('tennaqua')
            );
            
            // Store original and current players
            originalPlayers = [...tennaquaPlayers];
            allPlayers = [...tennaquaPlayers];
            
            console.log(`Loaded ${allPlayers.length} Tennaqua players (filtered from ${data.players.length} total)`);
            
            displayPlayers();
            updatePlayerCount();
        } catch (error) {
            console.error('Error loading players:', error);
            throw error;
        }
    }

    // Load series ranges from API
    async function loadSeriesRanges() {
        try {
            const response = await fetch('/api/create-team/analyze-series');
            if (!response.ok) throw new Error('Failed to fetch series');
            
            const data = await response.json();
            if (!data.success) {
                throw new Error(data.error || 'Failed to analyze series');
            }
            
            seriesRanges = data.series_ranges || [];
            console.log(`Loaded ${seriesRanges.length} series`);
            
            // Sequential order is now maintained automatically in real-time
            console.log('✅ Series loaded successfully - automatic ordering enabled');
            
            displaySeriesControls();
            displaySeriesTeams();
        } catch (error) {
            console.error('Error loading series:', error);
            throw error;
        }
    }

    // Legacy function removed - overlaps now handled automatically in real-time

    // Display players in the pool
    function displayPlayers() {
        const container = document.getElementById('available-players-pool');
        if (!container) {
            console.log('Available players container not found!');
            return;
        }

        console.log(`Displaying ${allPlayers.length} available players`);

        if (allPlayers.length === 0) {
            container.innerHTML = '<div class="text-gray-400 text-center text-sm">No players available</div>';
            return;
        }

        const playersHtml = allPlayers.map(player => {
            const ptiColorClass = getPTIColorClass(player.pti || 50);
            const playerHtml = `
                <div class="player-card ${ptiColorClass} border rounded-lg cursor-grab" 
                     data-player-id="${player.id}"
                     draggable="true"
                     ondragstart="handleDragStart(event, '${player.id}')"
                     ondragend="handleDragEnd(event)"
                     onclick="selectPlayer('${player.id}')">
                    <div class="text-sm font-semibold text-center">${player.name || `${player.first_name} ${player.last_name}`}</div>
                    <div class="text-xs text-center">PTI: ${player.pti ? player.pti.toFixed(1) : 'N/A'}</div>
                    <div class="text-xs text-gray-600 text-center">${player.club || ''}</div>
                </div>
            `;
            // Debug first player HTML
            if (player === allPlayers[0]) {
                console.log('Sample player HTML:', playerHtml);
                console.log('Player ID:', player.id);
                console.log('Player data:', player);
            }
            return playerHtml;
        }).join('');
        
        container.innerHTML = playersHtml;
        console.log('Available players HTML updated');
        
        // Check if drag events are properly attached
        setTimeout(() => {
            const playerCards = container.querySelectorAll('.player-card');
            console.log(`Found ${playerCards.length} player cards in DOM`);
            if (playerCards.length > 0) {
                const firstCard = playerCards[0];
                console.log('First player card:', firstCard);
                console.log('First card draggable:', firstCard.draggable);
                console.log('First card data-player-id:', firstCard.getAttribute('data-player-id'));
                console.log('First card ondragstart:', firstCard.getAttribute('ondragstart'));
            }
        }, 50);
    }

    // Handle player selection for mobile tap interface
    function selectPlayer(playerId) {
        const playerIdNum = parseInt(playerId, 10);
        const player = allPlayers.find(p => p.id === playerIdNum);
        if (!player) return;

        // Clear previous selection
        document.querySelectorAll('.player-card').forEach(card => {
            card.classList.remove('selected');
        });

        // Select current player
        selectedPlayerForTap = player;
        const playerCard = document.querySelector(`[data-player-id="${playerId}"]`);
        if (playerCard) {
            playerCard.classList.add('selected');
        }

        // Show selected player indicator
        const indicator = document.getElementById('selected-player-indicator');
        const nameSpan = document.getElementById('selected-player-name');
        const ptiSpan = document.getElementById('selected-player-pti');
        
        if (indicator && nameSpan && ptiSpan) {
            nameSpan.textContent = player.name || `${player.first_name} ${player.last_name}`;
            ptiSpan.textContent = `PTI: ${player.pti ? player.pti.toFixed(1) : 'N/A'}`;
            indicator.classList.remove('hidden');
        }
    }

    // Display series controls with individual PTI sliders
    function displaySeriesControls() {
        const container = document.getElementById('series-recommendations');
        if (!container) return;

        container.innerHTML = seriesRanges.map(series => `
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4" id="series-${series.series_name.replace(/\s+/g, '-')}">
                <h3 class="font-semibold text-gray-900 mb-2">${series.series_name}</h3>
                
                <!-- Current PTI Range Display -->
                <div class="mb-3 p-2 bg-blue-50 rounded-lg">
                    <div class="text-sm font-medium text-blue-900">Current PTI Range: 
                        <span id="current-range-${series.series_name.replace(/\s+/g, '-')}" class="font-bold">
                            ${series.current_range.min.toFixed(2)} - ${series.current_range.max.toFixed(2)}
                        </span>
                    </div>
                    <div class="text-xs text-blue-700 mt-1">
                        Players: ${series.player_count} | Avg PTI: ${series.statistics.avg.toFixed(2)} | StdDev: ${series.statistics.std_dev.toFixed(2)}
                    </div>
                </div>

                <!-- PTI Range Sliders -->
                <div class="space-y-3">
                    <!-- Min PTI Slider -->
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Min PTI: <span id="min-pti-value-${series.series_name.replace(/\s+/g, '-')}" class="font-semibold text-blue-600">${series.current_range.min.toFixed(2)}</span>
                        </label>
                        <input type="range" 
                               id="min-pti-slider-${series.series_name.replace(/\s+/g, '-')}"
                               class="series-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" 
                               min="-30" max="100" value="${series.current_range.min}" step="0.01"
                               data-series="${series.series_name}"
                               data-type="min"
                               onchange="updateSeriesPTIRange('${series.series_name}', 'min', this.value)">
                    </div>
                    
                    <!-- Max PTI Slider -->
                    <div>
                        <label class="block text-xs font-medium text-gray-700 mb-1">
                            Max PTI: <span id="max-pti-value-${series.series_name.replace(/\s+/g, '-')}" class="font-semibold text-blue-600">${series.current_range.max.toFixed(2)}</span>
                        </label>
                        <input type="range" 
                               id="max-pti-slider-${series.series_name.replace(/\s+/g, '-')}"
                               class="series-slider w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" 
                               min="-30" max="100" value="${series.current_range.max}" step="0.01"
                               data-series="${series.series_name}"
                               data-type="max"
                               onchange="updateSeriesPTIRange('${series.series_name}', 'max', this.value)">
                    </div>
                    
                                         <!-- Real-time Status Indicator -->
                     <div class="bg-green-50 border border-green-200 rounded-lg p-2">
                         <div class="flex items-center text-green-800">
                             <i class="fas fa-check-circle mr-2"></i>
                             <span class="text-xs font-medium">Sequential order maintained automatically</span>
                         </div>
                     </div>
                    
                    <!-- Recommended Range Info -->
                    <div class="text-xs text-gray-600 bg-gray-100 p-2 rounded">
                        <strong>Recommended:</strong> ${series.recommended_range.min.toFixed(2)} - ${series.recommended_range.max.toFixed(2)}
                    </div>
                </div>
            </div>
        `).join('');
    }

    // Display series teams
    function displaySeriesTeams() {
        const container = document.getElementById('series-teams');
        if (!container) {
            console.log('Series teams container not found!');
            return;
        }

        console.log('Updating series teams display...');
        console.log('Current team assignments:', teamAssignments);

        const seriesHtml = seriesRanges.map(series => {
            // Initialize target players if not set
            if (!playersPerSeries[series.series_name]) {
                playersPerSeries[series.series_name] = 10;
            }
            const currentPlayers = teamAssignments[series.series_name]?.length || 0;
            const targetPlayers = playersPerSeries[series.series_name];
            
            return `
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="font-semibold text-gray-900">${series.series_name}</h3>
                    <div class="flex items-center gap-2">
                        <div class="flex items-center gap-1">
                            <label class="text-xs text-gray-600">Target:</label>
                            <input type="number" 
                                   value="${targetPlayers}" 
                                   min="1" 
                                   max="20" 
                                   class="w-12 h-6 text-xs text-center border border-gray-300 rounded px-1"
                                   onchange="updateTargetPlayers('${series.series_name}', this.value)">
                        </div>
                        <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                            ${currentPlayers}/${targetPlayers} players added
                        </span>
                    </div>
                </div>
                <div class="drop-zone min-h-16 max-h-none border-2 border-dashed border-gray-300 rounded-lg p-3" 
                     style="height: auto; overflow: visible;"
                     data-series="${series.series_name}"
                     ondragover="handleDragOver(event)"
                     ondragenter="handleDragEnter(event)"
                     ondragleave="handleDragLeave(event)"
                     ondrop="handleDrop(event, '${series.series_name}')"
                     onclick="assignPlayerToSeries('${series.series_name}')">
                    <div id="team-${series.series_name}" class="flex flex-wrap gap-1 items-start">
                        ${teamAssignments[series.series_name] ? teamAssignments[series.series_name].map(player => `
                            <div class="player-card ${getPTIColorClass(player.pti)} border rounded cursor-grab"
                                 data-player-id="${player.id}"
                                 draggable="true"
                                 ondragstart="handleAssignedPlayerDragStart(event, '${player.id}', '${series.series_name}')"
                                 ondragend="handleDragEnd(event)"
                                 ondblclick="returnPlayerToPool('${player.id}', '${series.series_name}')">
                                <div class="font-medium text-center">${player.name || `${player.first_name} ${player.last_name}`}</div>
                                <div class="text-center">PTI: ${player.pti ? player.pti.toFixed(1) : 'N/A'}</div>
                                <div class="text-xs opacity-75 text-center">Double-click to remove</div>
                            </div>
                        `).join('') : '<div class="text-gray-400 text-sm w-full text-center py-4">Drag players here or tap to assign selected player</div>'}
                    </div>
                </div>
            </div>
            `;
        }).join('');
         
         container.innerHTML = seriesHtml;
         console.log('Series teams HTML updated');
     }

    // Assign player to series (mobile tap interface)
    function assignPlayerToSeries(seriesName) {
        if (!selectedPlayerForTap) {
            alert('Please select a player first');
            return;
        }

        // Initialize team assignments if needed
        if (!teamAssignments[seriesName]) {
            teamAssignments[seriesName] = [];
        }

        // Check if player already assigned
        const existingIndex = teamAssignments[seriesName].findIndex(p => p.id === selectedPlayerForTap.id);
        if (existingIndex !== -1) {
            alert('Player already assigned to this series');
            return;
        }

        // Add player to series
        teamAssignments[seriesName].push(selectedPlayerForTap);

        // Remove player from available pool
        allPlayers = allPlayers.filter(p => p.id !== selectedPlayerForTap.id);

        // Clear selection
        clearSelection();

        // Refresh displays
        displayPlayers();
        displaySeriesTeams();
        updatePlayerCount();
    }

    // Clear player selection
    function clearSelection() {
        selectedPlayerForTap = null;
        document.querySelectorAll('.player-card').forEach(card => {
            card.classList.remove('selected');
        });
        document.getElementById('selected-player-indicator').classList.add('hidden');
    }

    // Update player count
    function updatePlayerCount() {
        const countElement = document.getElementById('player-count');
        if (countElement) {
            countElement.textContent = allPlayers.length;
        }
    }

    // Update target players for a series
    function updateTargetPlayers(seriesName, target) {
        const targetNum = parseInt(target, 10);
        if (targetNum >= 1 && targetNum <= 20) {
            playersPerSeries[seriesName] = targetNum;
            console.log(`Updated ${seriesName} target to ${targetNum} players`);
            
            // Refresh the display to show the updated "X/Y players added" text
            displaySeriesTeams();
        } else {
            console.warn(`Invalid target: ${target}. Must be between 1 and 20.`);
        }
    }

    // This function is no longer needed since we're not using team size sliders
    // Keeping for backwards compatibility
    function updateTeamSize(seriesName, size) {
        console.log(`Team size update for ${seriesName}: ${size} (feature not implemented)`);
    }

    // Setup event listeners
    function setupEventListeners() {
        // Clear selection button
        document.getElementById('clear-selection')?.addEventListener('click', clearSelection);

        // Reset buttons
        document.getElementById('reset-players')?.addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('calculate-balanced-ranges')?.addEventListener('click', () => {
            calculateBalancedRanges();
        });

        document.getElementById('reset-ranges')?.addEventListener('click', () => {
            resetSeriesRanges();
        });

        document.getElementById('reset-assignments')?.addEventListener('click', () => {
            teamAssignments = {};
            displaySeriesTeams();
        });

        document.getElementById('reset-teams')?.addEventListener('click', () => {
            location.reload();
        });

        // Save teams button
        document.getElementById('save-teams')?.addEventListener('click', saveTeams);
    }

    // Save teams functionality
    async function saveTeams() {
        try {
            // Transform team assignments to match API expectations
            const formattedTeams = {};
            for (const seriesName in teamAssignments) {
                const players = teamAssignments[seriesName];
                const totalPti = players.reduce((sum, player) => sum + (player.pti || 0), 0);
                
                formattedTeams[seriesName] = {
                    players: players,
                    total_pti: totalPti,
                    avg_pti: players.length > 0 ? totalPti / players.length : 0
                };
            }
            
            const response = await fetch('/api/create-team/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    teams: formattedTeams,
                    series_data: seriesRanges
                })
            });

            const data = await response.json();
            
            if (data.success) {
                alert('Teams saved successfully!');
            } else {
                throw new Error(data.error || 'Failed to save teams');
            }
        } catch (error) {
            console.error('Error saving teams:', error);
            alert('Failed to save teams. Please try again.');
        }
    }

    // Show content and hide loading
    function showContent() {
        console.log('showContent() called');
        const loadingState = document.getElementById('loading-state');
        const mainContent = document.getElementById('create-team-content');
        
        if (loadingState) {
            loadingState.classList.add('hidden');
            loadingState.style.setProperty('display', 'none', 'important');
            console.log('Loading state hidden');
        } else {
            console.log('Loading state element not found');
        }
        
        if (mainContent) {
            mainContent.classList.remove('hidden');
            mainContent.style.setProperty('display', 'block', 'important');
            console.log('Create team content shown');
        } else {
            console.log('Create team content element not found');
        }
    }

    // Show error message
    function showError(message) {
        const loadingState = document.getElementById('loading-state');
        loadingState.innerHTML = `
            <div class="text-red-600 text-center">
                <i class="fas fa-exclamation-triangle text-2xl mb-3"></i>
                <p class="text-lg">${message}</p>
            </div>
        `;
    }

    // Drag and Drop Functions
    let draggedPlayer = null;

    window.handleDragStart = function(event, playerId) {
        console.log('=== DRAG START EVENT ===');
        console.log('Player ID:', playerId, typeof playerId);
        console.log('All players count:', allPlayers.length);
        
        // Convert playerId to number to match player object id
        const playerIdNum = parseInt(playerId, 10);
        console.log('Player ID as number:', playerIdNum);
        
        const player = allPlayers.find(p => p.id === playerIdNum);
        console.log('Found player:', player);
        
        if (player) {
            draggedPlayer = player;
            event.dataTransfer.setData('text/plain', playerId);
            event.target.style.opacity = '0.5';
            console.log('Drag started successfully for player:', player.name || `${player.first_name} ${player.last_name}`);
            console.log('draggedPlayer variable set:', draggedPlayer);
        } else {
            console.log('ERROR: Player not found in allPlayers array');
            console.log('Available player IDs:', allPlayers.map(p => p.id));
        }
    };

    window.handleDragEnd = function(event) {
        event.target.style.opacity = '1';
        draggedPlayer = null;
    };

    window.handleDragOver = function(event) {
        event.preventDefault(); // Allow drop
        event.dataTransfer.dropEffect = 'move';
    };

    window.handleDragEnter = function(event) {
        event.preventDefault();
        if (event.target.classList.contains('drop-zone')) {
            event.target.classList.add('drop-zone-active');
            event.target.style.borderColor = '#3b82f6';
            event.target.style.backgroundColor = '#eff6ff';
        }
    };

    window.handleDragLeave = function(event) {
        if (event.target.classList.contains('drop-zone')) {
            event.target.classList.remove('drop-zone-active');
            event.target.style.borderColor = '#d1d5db';
            event.target.style.backgroundColor = '';
        }
    };

    window.handleDrop = function(event, seriesName) {
        event.preventDefault();
        
        console.log('=== DROP EVENT START ===');
        console.log('Drop target:', event.target);
        console.log('Series name:', seriesName);
        console.log('Dragged player:', draggedPlayer);
        
        // Reset drop zone styling
        if (event.target.classList.contains('drop-zone')) {
            event.target.classList.remove('drop-zone-active');
            event.target.style.borderColor = '#d1d5db';
            event.target.style.backgroundColor = '';
        }
        
        if (!draggedPlayer) {
            console.log('No player being dragged');
            return;
        }

        console.log(`Dropped player ${draggedPlayer.name || `${draggedPlayer.first_name} ${draggedPlayer.last_name}`} into ${seriesName}`);
        
        // Initialize team assignments if needed
        if (!teamAssignments[seriesName]) {
            teamAssignments[seriesName] = [];
        }

        // Check if player already assigned to this series
        const existingIndex = teamAssignments[seriesName].findIndex(p => p.id === draggedPlayer.id);
        if (existingIndex !== -1) {
            console.log('Player already assigned to this series');
            return;
        }

        // If player is moving from another series, remove from there first
        if (draggedPlayer.fromSeries) {
            const fromIndex = teamAssignments[draggedPlayer.fromSeries].findIndex(p => p.id === draggedPlayer.id);
            if (fromIndex !== -1) {
                teamAssignments[draggedPlayer.fromSeries].splice(fromIndex, 1);
                console.log(`Moved player from ${draggedPlayer.fromSeries} to ${seriesName}`);
            }
            delete draggedPlayer.fromSeries;
        } else {
            // Remove player from available pool (if coming from pool)
            allPlayers = allPlayers.filter(p => p.id !== draggedPlayer.id);
        }

        // Add player to target series
        teamAssignments[seriesName].push(draggedPlayer);

        // Clear any existing selection
        clearSelection();

        // Refresh displays
        console.log('Refreshing displays after drop...');
        console.log('Available players count:', allPlayers.length);
        console.log('Team assignments:', teamAssignments);
        
        displayPlayers();
        displaySeriesTeams();
        updatePlayerCount();
        
        console.log('Player successfully assigned to series');
        console.log('=== DROP EVENT COMPLETE ===');
        
        // Force a refresh after a brief delay to ensure DOM updates
        setTimeout(() => {
            console.log('Delayed refresh after drop');
            displayPlayers();
            displaySeriesTeams();
            updatePlayerCount();
        }, 100);
    };

    // Handle dropping player back to available pool
    window.handleDropToPool = function(event) {
        event.preventDefault();
        
        // Reset drop zone styling
        if (event.target.classList.contains('drop-zone') || event.target.closest('.drop-zone')) {
            const dropZone = event.target.classList.contains('drop-zone') ? event.target : event.target.closest('.drop-zone');
            dropZone.classList.remove('drop-zone-active');
            dropZone.style.borderColor = '#d1d5db';
            dropZone.style.backgroundColor = '';
        }
        
        if (!draggedPlayer || !draggedPlayer.fromSeries) {
            console.log('Can only return assigned players to pool');
            return;
        }

        console.log(`Returning player ${draggedPlayer.name || `${draggedPlayer.first_name} ${draggedPlayer.last_name}`} to available pool`);
        
        // Remove from assigned series
        const fromIndex = teamAssignments[draggedPlayer.fromSeries].findIndex(p => p.id === draggedPlayer.id);
        if (fromIndex !== -1) {
            teamAssignments[draggedPlayer.fromSeries].splice(fromIndex, 1);
        }
        
        // Clean up the fromSeries property
        delete draggedPlayer.fromSeries;
        
        // Add back to available players
        allPlayers.push(draggedPlayer);

        // Clear any existing selection
        clearSelection();

        // Refresh displays
        displayPlayers();
        displaySeriesTeams();
        updatePlayerCount();
        
        console.log('Player successfully returned to available pool');
    };

    // Handle dragging assigned players (for moving between series or back to pool)
    window.handleAssignedPlayerDragStart = function(event, playerId, fromSeries) {
        // Find player in the assigned teams
        const playerIdNum = parseInt(playerId, 10);
        const player = teamAssignments[fromSeries].find(p => p.id === playerIdNum);
        if (player) {
            draggedPlayer = player;
            draggedPlayer.fromSeries = fromSeries; // Track where it came from
            event.dataTransfer.setData('text/plain', playerId);
            event.target.style.opacity = '0.5';
            console.log(`Drag started for assigned player: ${player.name || `${player.first_name} ${player.last_name}`} from ${fromSeries}`);
        }
    };

    // Return player to available pool
    window.returnPlayerToPool = function(playerId, fromSeries) {
        const playerIdNum = parseInt(playerId, 10);
        const playerIndex = teamAssignments[fromSeries].findIndex(p => p.id === playerIdNum);
        if (playerIndex !== -1) {
            const player = teamAssignments[fromSeries][playerIndex];
            
            // Remove from assigned series
            teamAssignments[fromSeries].splice(playerIndex, 1);
            
            // Add back to available players
            allPlayers.push(player);
            
            // Refresh displays
            displayPlayers();
            displaySeriesTeams();
            updatePlayerCount();
            
            console.log(`Player ${player.name || `${player.first_name} ${player.last_name}`} returned to available pool`);
        }
    };

    // Make functions globally available
    window.selectPlayer = selectPlayer;
    window.assignPlayerToSeries = assignPlayerToSeries;
    window.updateTeamSize = updateTeamSize;
    window.updateTargetPlayers = updateTargetPlayers;

    // Debug functions
    window.forceShowContent = function() {
        console.log('Forcing content to show...');
        const loadingState = document.getElementById('loading-state');
        const mainContent = document.getElementById('create-team-content');
        
        if (loadingState) {
            loadingState.classList.add('hidden');
            loadingState.style.setProperty('display', 'none', 'important');
            console.log('Loading state hidden');
        }
        
        if (mainContent) {
            mainContent.classList.remove('hidden');
            mainContent.style.setProperty('display', 'block', 'important');
            console.log('Create team content shown');
        }
        
        console.log('Content force-show complete');
    };

    window.debugPageState = function() {
        console.log('=== PAGE DEBUG INFO ===');
        console.log('Players loaded:', allPlayers.length);
        console.log('Series loaded:', seriesRanges.length);
        console.log('Team assignments:', teamAssignments);
        
        const loadingState = document.getElementById('loading-state');
        const mainContent = document.getElementById('create-team-content');
        
        console.log('Loading state classes:', loadingState ? loadingState.className : 'not found');
        console.log('Create team content classes:', mainContent ? mainContent.className : 'not found');
        console.log('Loading state display:', loadingState ? loadingState.style.display : 'not found');
        console.log('Create team content display:', mainContent ? mainContent.style.display : 'not found');
    };

    // Manual refresh function for testing
    window.refreshDisplays = function() {
        console.log('Manual refresh triggered');
        displayPlayers();
        displaySeriesTeams();
        updatePlayerCount();
    };

    // Test drag start function for debugging
    window.testDragStart = function() {
        console.log('Testing drag start with first player...');
        if (allPlayers.length > 0) {
            const firstPlayer = allPlayers[0];
            console.log('First player:', firstPlayer);
            console.log('Player ID:', firstPlayer.id);
            
            // Simulate drag start
            draggedPlayer = firstPlayer;
            console.log('Manually set draggedPlayer:', draggedPlayer);
        } else {
            console.log('No players available to test');
        }
    };

    // Initialize page
    initializePage();
    
    // Failsafe: Force show content after 5 seconds if still hidden
    setTimeout(function() {
        const mainContent = document.getElementById('create-team-content');
        if (mainContent && mainContent.classList.contains('hidden')) {
            console.log('Failsafe: Forcing content to show after timeout');
            showContent();
        }
    }, 5000);
});
</script>
{% endblock %} 